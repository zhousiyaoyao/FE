# 目录
* [对称加密，非对称加密，中间人攻击](#对称加密，非对称加密，中间人攻击)
* [数字证书，数字签名，认证中心](#数字证书，数字签名，认证中心)
* [HTTP握手和分手](#HTTP握手和分手)
* [HTTPS握手](#HTTPS握手)
* [HTTPS详解](#HTTPS详解)
* [TCP，UDP](#TCP，UDP)
* [TCP拥塞控制](#TCP拥塞控制)
* [OSI七层模型和TCP/IP模型](#OSI七层模型和TCP/IP模型)
* [HTTP请求](#HTTP请求)
* [前端安全](#前端安全)
* [http2.0](#http2.0)

### 对称加密，非对称加密，中间人攻击
1. 对称加密，加密解密使用同一把密钥，一般HTTPS的对称加密算法有AES，RC4，3DEC。优点效率高，速度快，解决保密性问题，缺点安全性较低，且难保证消息来源的可靠性，消息的完整性和准确性
2. 非对称加密，使用公钥和私钥加密，公钥加密的只能私钥开，私钥加密的只能公钥开，HTTPS一般使用RSA，DSA/DSS，优点风险低，一定程度上保证消息来源的可靠性，消息的完整性和准确性，但是效率低，速度慢，性能不行，而且还是有可能不安全，比如第一中间人可以在客户端和服务器交换公钥的时候，把客户端的公钥替换成服务器的。这样服务器拿到的公钥将不是客户端的，而是服务器的，服务器无法判断公钥来源的正确性。第二中间人可以截获客户端的消息，然后篡改，再用服务器的公钥加密发往服务器，服务器就会收到错误的信息。
3. 两者结合：服务器有公钥A和私钥A+，服务器把公钥A明文发给客户端，客户端生成一个对称加密的密钥X，用共钥A加密后传给服务器，服务器用私钥解密，得到X，这样双方都有密钥X了，且别人无法知道，之后双方所有数据都用密钥X加密解密
4. 中间人攻击：服务器有公钥A和私钥A+，服务器把公钥A明文发给客户端，中间人劫持公钥A，把公钥A替换成自己伪造的公钥B，当然他也有私钥B+，客户端生成对称加密密钥X，用B加密X传给服务器，中间人劫持用后用B+解密得到密钥X，再用公钥A加密传给服务器，服务器用A+解密得到X。这样双方都不知道异常的情况下，中间人得到了密钥X。根本原因在于客户端不知道自己收到的公钥是不是网站自己的。

### 数字证书，数字签名，认证中心
1. 数字签名，把证书内容生成一份签名，对比证书内容和签名是否一致来察觉是否被篡改
2. CA具有非对称加密的公钥和私钥，CA对证书明文信息（服务器个人信息+服务器公钥）进行hash得到信息摘要，对信息摘要用私钥加密，得到数字签名。
3. 证书明文信息和数字签名共同组成了数组证书，这样一份数字证书就可以办法给网站了
4. 客户端拿到服务器传来的数字证书，用hash算法对明文进行hash得到T，用CA给的公钥对S解密得到S+，比较T和S+是否相同，相同则可信
5. hash的作用是因为证书信息一般很长，hash之后得到的是固定的长度，这样加密解密就很快。还有安全上的问题
6. HTTPS不需要每次都握手，因为可以维护一个session id，TSL握手结束后，浏览器把密钥传给服务器，服务器把密钥放在session id下，之后每次浏览器请求携带session id

### HTTP握手和分手
1. TCP 3次握手（确保双方都有接受和发送的能力），发syn我想链接，收ack我同意了，发ack我收到了，开始发送
2. TCP 4次挥手（确保发送方已经发完，接受双方已经接受完），发fin我已经发完了，接ack我收到了，接ack和fin我也没东西发送了，发ack我收到了

### HTTPS握手
1. 客户端向服务器发起请求，包括生成的随机数
2. 服务器收到请求，给出服务器证书，和服务器生成的随机数，确认要用的加密算法
3. 客户端确认证书有效后，生成一个新的随机数，用公钥加密这个随机数，然后发给服务器，还要提供一个hash值
4. 服务器用自己的私钥，来解密客户端的随机数，并提供hash值来供客户端检验
5. 客户端和服务器用约定的加密方法使用前面的三个随机数，生成对话秘钥，以后用这个秘钥来加密信息

### HTTPS详解
https是以安全为目标的http通道，是http加上TLS/SSL协议构建的可进行加密传输，身份认证的网络协议，主要通过数字证书，加密算法，非对称密钥等技术完成数据传输，HTTP+加密+认证+完整性保护 = HTTPS。不是应用层的新协议，只是http通信接口部分用ssl协议和tls协议替代而已。
http默认端口为80，https默认端口为443。
https比http慢。HTTPS比HTTP要慢2到100倍：SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。


##### 为什么需要HTTPS
因为http不安全
1. 通信使用明文，无法保证消息的保密性（内容被窃听）
2. 不验证通信方的身份，无法确保消息来源的可靠性（内容被伪装）
3. 无法验证报文的完整性和准确性（内容可能被篡改）

### TCP，UDP
1. TCP
* 面向连接
* 可靠传输，流量控制和拥塞控制
* 一对一通信
* 面向字节流
* 首部最小20字节，最大60字节
* 适用于要求可靠传输的应用，例如文件传输
2. UDP
* 无连接
* 不可靠传输，不使用流量控制和拥塞控制
* 一对一，多对多，一对多，多对一
* 面向报文
* 首部开销小，仅8字节
* 适用于实时应用，IP电话，视频会议，直播

### TCP拥塞控制
1. 慢启动，因为不知道网络拥塞程度，先低速率发送，每收到一个确定报文，发送窗口长度加一，每个RTT时间后，长度加倍，超过一个阀值，进入拥塞避免算法
2. 拥塞避免，每个RTT时间，长度只加1，来避免发送拥塞
3. 快速重传，收到3个冗余的确认应答时，发送所有已经发送但还没有接收到确认应答的报文段
4. 快速恢复，慢启动阀值减少到原来一半，将拥塞窗口的值设为减半后的阀值，然后开始拥塞避免


### OSI七层模型和TCP/IP模型
1. 应用层
* 应用层：文件传输，电子邮件，文件服务，虚拟终端，TFTP，HTTP，SNMP，SMTP，DNS，Telnet
* 表示层：数据格式化，代码转换，数据加密，无协议
* 会话层：解除或建立与别的接点的联系，无协议
2. 传输层：提供端对端的接口，TCP，UDP
3. 网络层：为数据包选择路由，IP，ICMP，RIP，OSPF，BGP，IGMP
4. 链路层
* 数据链路层：传输有地址的帧以及错误检测功能，SLIP，CSLIP，PPP，ARP，RARP，MTU
* 物理层：以二进制数据形式在物理媒体上传输数据，ISO2110，IEEE802，IEEE802.2

### HTTP请求
1. Head:检查超链接的有效性，检查资源的有效性，可被缓存，不返回消息体，获取请求中隐含的元信息。仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容
2. Options:CORS预检请求，对服务器数据可能产生副作用的请求方法（复杂请求），获知服务端是否允许跨域请求。发送请求内容类型不是application/x-www-form-urlencoded，multipart/formdata或text/plain的话，会触发options请求。措施，用qs序列化对象，或者URLSearchParams，emulateJSON。简单请求：HEAD，GET，POST

### 前端安全
1. Xss攻击
* Cross-site scripting，代码注入攻击，恶意代码嵌入，并被浏览器执行，注入html，注入标签属性，注入事件，注入css，注入js
* 存储型，存在数据库，论坛，评论，私信
* 反射型，存在url，网站搜索，跳转，用户点击恶意url
* DOM型，前端责任，插入在js
* 防范：Cookie设置httponly，输入检查，否则会被绕过直接发起请求，避免innerHTML，内联监听器少用，href
2. Csrf攻击
* Cross-site request forgery，跨站请求伪造
* 在不登出A的情况下，访问恶意网站B，B获取A的cookie，模拟用户操作
* 验证码，token（最合适方法）

### http2.0
1. 服务器推送
2. 头信息压缩，维护一个头信息表，只传改变的
3. 二进制形式传帧
4. 多路复用，一个request对应一个id，一个连接可以有多个request。与1.1长连接的区别在于1.1要排队，会出现阻塞