---
title: 时尚版性能优化
type: categories
copyright: true
date: 2020-05-22 21:15:57
tags: 性能优化
categories: 性能优化
---

### 前言

前端性能优化的目的不是追求一味的快，而是优化用户的体验，即使没有实质化的优化，让用户产生性能快的错觉，也是性能优化，用户觉得快，就是真的快，比如加loading。

### 加载优化（大部分）

1. **首屏loading**：html-webpack-plugin，js执行期间加入提示，在文件中插入loading图
2. **预渲染**：prerender-spa-plugin，模拟浏览器获取首屏的html结构，在本地模拟浏览器环境，预先执行我们的打包文件，这样通过解析可以获取首屏的html，在正常环境中，可以返回预先解析好的HTML
3. **开启HTTP2**：浏览器并发限制一次性6次请求，http2二进制分帧进行通信，多路复用，只需一个tcp通道，请求和响应可以双向通信，头部压缩，只发送差异数据，维护头信息表，以后只发索引号。服务器推送，无需请求，减少多次请求的耗时
4. **开启浏览器缓存**：给第三方库设置强缓存，SplitChunksPlugin来做拆包，需要将应用基础库和特定依赖库分离。当chunk在强缓存期但服务器代码变了，需要通知客户端，需要每次引入script脚本的时候去服务器更新，并开启hashchunk，作用是当chunk变化时，hash值也会变，所以不变就命中缓存，变了重新请求
5. **骨架图**：antd的骨架屏Skeleton，vue的SkeletonWebpackPlugin，让骨架屏的css分离，直接作为内联style处理到html，提高载入速度
6. **Tree shaking**：通过程序流分析找出你代码中无用的代码并剔除，webpack4自带，坑Babel转译，因为需要es5的module，需要手动关闭commonjs；坑2第三方库不可控，因为有些只有es5版本
7. **路由分割优化**：只加载当前页面的代码，比如component: ()=> import('@components/login'), 这样登陆页会被单独打包
8. **组件懒加载**：在页面的加载中只渲染部分必须的组件,而其余的组件可以按需加载。基于lazy+suspense，比如把echart的图进行懒加载
9. **组件预加载**：在用户的鼠标还处于hover状态的时候就开始触发图表资源的加载,通常情况下当用户点击结束之后,加载也基本完成,这个时候图表会很顺利地渲染出来,不会出现延迟
10. **keep alive**：vue中，在页面跳转后不销毁组件，先保存组件对应的实例到内存，当页面需要再次渲染时，可以利用这个缓存。但实例过多容易出现内存泄漏，注意调用deactivated销毁。react官网宣布不会加类似api，但可以用redux状态缓存（不推荐），或者React Keep Alive这个库
11. **图片懒加载**：页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。可见区域监听滚动事件
12. **资源压缩**：服务端启动gzip
13. **CDN**：静态资源走CDN，使用户就近获取内容，降低访问时延，减轻了源站的负载。静态资源不需要cookie，把静态资源和主页面置于不同的域名下，可以避免请求中携带不必要的cookie（同一个域名下的所有请求，都会携带一个相同的cookie，设置不当就会很大）
14. **雪碧图，icon**：这个不解释

### 执行优化（小部分）

动画一般是性能的重灾区，需要大量的计算和渲染，主要有三种方式：
1. Canvas
2. CSS3
3. Dom

动画优化方案：
1. **Dom优化之Dom+js**：容易引起回流和重绘，优化就是不用Dom+js做动画
2. **CSS3优化之动画放在同一图层（合成层）**：图层的概念，浏览器渲染页面，会把页面分成很多图层，对每个图层的节点计算样式，生成图形和位置，再把节点绘制到图层位图中，图层作为纹理上传至GPU，图层重组生成屏幕图像。将动画放在一个独立图层,这样可以避免动画效果影响其他渲染层的元素。比如iframe，video，3D或2D canvas，flash，3D transform，backface-visibility 为 hidden等
3. **CSS3优化之避免重绘和回流**：多使用transform和opacity来实现动画效果
4. **CSS3优化之GPU加速**：浏览器把一部分渲染任务丢给GPU。这部分css元素会提升到合成层，使得当页面上只有这个元素发生变换(transform)的时候其余元素不需要重新渲染。opacity，translate，rotate和scale会触发硬件加速，opacity号称性能最好的属性之一。
5. **CSS3优化之will change**：will-change，最好的方式，设置为opacity，transform或上下左右，允许我们提前告知浏览器可能会对元素进行哪些操作，让浏览器去优化并提前处理那些潜在的比较消耗性能的操作比如在动画开始之前，提前处理元素的动画行为。过多使用会占用计算机资源，且需要留足够时间，变更失效需要移除。
6. **Canvas优化之requestAnimationFrame**：setInterval定时完成动画不可靠，容易掉帧。requestAnimationFrame性能好，将所有动画放到一个浏览器重绘周期里去做，这样可以保存cpu循环次数，提高性能。开销更小，浏览器专门为动画提供的效果，运行时浏览器会自动优化方法的调用，如果页面不是激活状态，动画会暂停，节省了cpu开销
7. **Canvas优化之离屏canvas**：离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 canvas的 API的消耗。
8. **Canvas优化之避免浮点运算**：浮点数可能会使元素抖动或者抗锯齿失真
9. **Canvas优化之减少调用Canvas API**：通过适量js原生计算减少canvas API的调用，粒子效果少用圆，最好用方形
10. **Web woker**：分担主线程的压力

大量数据性能优化方案：
1. **虚拟列表**：只渲染可视区域的数据，startIndex，endIndex，计算startOffset
2. **webwork**：完全和UI线程（主线程）并行的执行js代码，从而不会阻塞UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素